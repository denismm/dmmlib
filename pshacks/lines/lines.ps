%!

/acos {
    dup dup mul 1 exch sub sqrt exch atan
} def
/asin {
    dup dup mul 1 exch sub sqrt atan
} def
/tan {
    dup sin exch cos div
} def

% handle zeros
/myatan {
    dup 0 eq {
        pop dup 0 eq {
            pop 0
        } {
            0 atan
        } ifelse
    } {
        atan
    } ifelse
} def

% mod that accepts floats and makes negatives positive
/mod_dict 2 dict def
/mymod {
    mod_dict begin
	/modulus exch def
	/original exch def
	original 0 lt original modulus ge or {
	    original modulus div floor neg 
	    modulus mul original add 
	    /original exch def
	} if
	original
    end
} def

% allow division by zero
/zdiv {
    dup 0 eq {
	pop pop 0
    } {
	div
    } ifelse
} def

/boltdict 20 dict def


/pathlength {
    boltdict begin
        gsave
            flattenpath
            /startx /None def
            /starty /None def
            /oldx /None def
            /oldy /None def
            /linelen 0 def
            /handle_line {
                /newy arg /newx arg
                newx oldx sub dup mul
                newy oldy sub dup mul
                add sqrt linelen add /linelen exch def
                /oldx newx def
                /oldy newy def
            } def
            {
                /starty arg
                /startx arg
                /oldy starty def
                /oldx startx def
            }
            {
                handle_line
            }
            { pop pop pop pop pop pop }
            { startx starty handle_line}
            pathforall
        grestore
        linelen
    end
} def


boltdict begin
    /pathtolineslengthp { /include_length arg
	% analyze current path, creating pathpoints array
	% turn all curves into lines
	% pathpoints format: [x y lengthsofar] if include_length

        flattenpath
        /pathcount 0 def
	/closed false def
        gsave
            { pop pop /pathcount pathcount 1 add def } % moveto
            { pop pop /pathcount pathcount 1 add def } % lineto
            { quit } % curveto
            { /pathcount pathcount 1 add def /closed true def} % closepath
	    pathforall
        grestore
        % pathcount is number of points in line
        /pathpoints pathcount array def
	/i 0 def
	/x 0 def /y 0 def /linelen 0 def
        /addpoint {
            pathpoints i [x y 
                include_length {
                    linelen
                } if
            ] put
            /i i 1 add def
        } def

	/addline {
	    i 0 eq {quit} if
	    /ny exch def /nx exch def
	    % segment length
	    /seglen ny y sub dup mul nx x sub dup mul add sqrt def
	    seglen currentlinewidth 10 div gt {
		% linelen += length, update x and y
		seglen linelen add /linelen exch def
		/x nx def /y ny def
                addpoint
	    } {
		/pathcount pathcount 1 sub def
	    } ifelse
	} def

	% moveto
	{
	    /y exch def /x exch def
	    i 0 ne {quit} if
            addpoint
	}
	{ addline } % lineto
	{ quit } % curve
	{
	    /ny pathpoints 0 get 1 get def
	    /nx pathpoints 0 get 0 get def
	    nx ny addline
	} % close
	pathforall
    } def
    /pathtolines {true pathtolineslengthp} def

    % internal helper function for calligraphic, etc.
    /pathtocurves {
	% analyze current path, creating pathpoints array
	% save all lines as 4-point curves
	% pathpoints format: [x y lengthsofar ptype]
	% ptype is /p for point or /c for control point

	% count points in path & determine closedness

	/pathcount 0 def
	/closed false def
        gsave
            { 2 {pop} repeat /pathcount pathcount 1 add def } % moveto
            { 2 {pop} repeat /pathcount pathcount 3 add def } % lineto
            { 6 {pop} repeat /pathcount pathcount 3 add def } %curveto
            { /pathcount pathcount 3 add def /closed true def } % closepath
	    pathforall
        grestore
        % pathcount is number of points in line

	% move path points into array
        /pathpoints pathcount array def
	/i 0 def
	/x 0 def /y 0 def /linelen 0 def

	% define internal helper functions
	/addcurve {
	    % at this point, treat as 3 line segments
	    % tag control points as "c" instead of "p"
	    6 2 roll
	    4 2 roll
	    /types [/c /c /p] def
	    /curvelen 0 def
	    /curvepoints 3 array def
	    /ci 0 def
	    3 {
		/ny exch def /nx exch def
		% segment length
		ny y sub dup mul nx x sub dup mul add sqrt
		% linelen += length, update x and y
		curvelen add /curvelen exch def
		/x nx def /y ny def
		/ptype types ci get def
		curvepoints ci [x y linelen curvelen add ptype] put
		/ci ci 1 add def
	    } repeat
	    curvelen currentlinewidth 10 div gt {
		/linelen linelen curvelen add def
		0 1 2 {
		    /ci exch def
		    pathpoints ci i add curvepoints ci get put
		} for
		/i i 3 add def
	    } {
                % if curve is too small, drop it from path
		/pathcount pathcount 3 sub def
	    } ifelse
	} def

	/addline {
	    /ny exch def /nx exch def
	    % create fake control points
	    x 2 mul 3 div nx 3 div add  y 2 mul 3 div ny 3 div add
	    x 3 div nx 2 mul 3 div add  y 3 div ny 2 mul 3 div add
	    nx ny
	    addcurve
	} def

	% args to pathforall
	% moveto
	{
	    /y exch def /x exch def
	    i 0 ne {quit} if
	    pathpoints i [x y linelen /p] put
	    /i i 1 add def
	}
	% lineto
	{
	    i 0 eq {quit} if
	    addline
	}
	% curve
	{ 
	    i 0 eq {quit} if
	    addcurve
	}
	% close
	{
	    i 0 eq {quit} if
	    /closed true def
	    /ny pathpoints 0 get 1 get def
	    /nx pathpoints 0 get 0 get def
	    nx ny addline
	} pathforall
    } def

    /drawbevel {
	/forward exch def
	forward {
	    /a1 direction def
	    /a2 direction_2 def
	} {
	    /a1 direction_2 def
	    /a2 direction def
	} ifelse
	currentlinejoin 1 eq {
	    a1 a2 sub
	    dup 0.1 le { 360 add } if
	    dup 180 lt {
		a2 add /a1 exch def
		x y lineout a1 a2 arcn
	    } {
		pop
		x a2 cos lineout mul add
		y a2 sin lineout mul add
		lineto
	    } ifelse
	} {
	    x a2 cos lineout mul add
	    y a2 sin lineout mul add
	    lineto
	} ifelse
    } def
end

% line of varying widths, using only lineto
% call with function that determines "line radius" (1/2 thickness)
/var_line {
    boltdict begin
	/radfunc exch def

	pathtolines

        linelen 0 gt {

            % determine miter and bevel points and directions
            0 1 pathcount 1 sub {
                /i exch def
                /l i 0 eq { pathcount 2 sub } { i 1 sub } ifelse def
                /n i pathcount 1 sub eq { 1 } { i 1 add } ifelse def

                /cur_point pathpoints i get def
                /x cur_point 0 get def
                /y cur_point 1 get def
                /dist cur_point 2 get def

                /next_point pathpoints n get def
                /nx next_point 0 get def
                /ny next_point 1 get def
                /ndir ny y sub nx x sub myatan def

                /last_point pathpoints l get def
                /lx last_point 0 get def
                /ly last_point 1 get def
                /ldir ly y sub lx x sub myatan def

                /bevel false def
                /direction_2 0 def

                % effective line radius at this point
                /linerad radfunc exec def

                i 0 eq i pathcount 1 sub eq or closed not and {
                    /lineout linerad def
                    i 0 eq {
                        /direction ndir 90 add def
                        currentlinecap 2 eq {
                            /x x ndir cos neg lineout mul add def
                            /y y ndir sin neg lineout mul add def
                        } if
                    } {
                        /direction ldir 90 sub def
                        currentlinecap 2 eq {
                            /x x ldir cos neg lineout mul add def
                            /y y ldir sin neg lineout mul add def
                        } if
                    } ifelse
                    /direction_2 direction def
                } {
                    /theta ndir ldir sub def
                    theta 0 lt {
                        /theta theta 360 add def
                    } if
                    /phi 90 theta 2 div sub def
                    % actual distance to junction point
                    phi cos 0 eq {
                        /lineout 0 def
                    } {
                        /lineout linerad phi cos div def
                    } ifelse
                    % direction to junction point
                    /direction ndir 90 add phi add def
                    0 currentlinejoin ne
                    lineout linerad zdiv currentmiterlimit gt or {
                        /bevel true def
                        /lineout linerad def
                        /direction ldir 90 sub 360 mymod def
                        /direction_2 ndir 90 add 360 mymod def
                        i pathcount 1 sub eq {
                            /bevel false def
                        } if
                    } {
                        /direction_2 direction def
                    } ifelse
                } ifelse
                pathpoints i [x y dist /l direction lineout bevel direction_2] put
            } for

            % draw line
            newpath
            % side 1
            0 1 pathcount 1 sub {
                /i exch def
                /cur_point pathpoints i get def
                /x cur_point 0 get def
                /y cur_point 1 get def
                /direction cur_point 4 get def
                /lineout cur_point 5 get def
                /bevel cur_point 6 get def
                /direction_2 cur_point 7 get def
                x direction cos lineout mul add
                y direction sin lineout mul add
                i 0 eq {
                    moveto
                } {
                    lineto
                } ifelse
                bevel {
                    true drawbevel
                } if
            } for
            % end circle as needed
            currentlinecap 1 eq {
                x y lineout direction direction 180 add arcn
            } {
                /direction direction 180 add def
                x direction cos lineout mul add
                y direction sin lineout mul add
                lineto
            } ifelse
            % side 2
            pathcount 2 sub -1 0 {
                /i exch def
                /cur_point pathpoints i get def
                /x cur_point 0 get def
                /y cur_point 1 get def
                /direction cur_point 4 get 180 add def
                /lineout cur_point 5 get def
                /bevel cur_point 6 get def
                /direction_2 cur_point 7 get 180 add def
                x direction_2 cos lineout mul add
                y direction_2 sin lineout mul add
                lineto
                bevel { false drawbevel } if
            } for
            % start circle if needed
            currentlinecap 1 eq {
                x y lineout direction direction 180 add arcn
            } if
            closepath
        } if
    end
} def

/outline {
    boltdict begin
        /linefunc arg
        gsave
            linefunc
            setlinewidth
            stroke
        grestore
        newpath
    end
} def

/bolt {
    { dist linelen div 1 exch sub currentlinewidth mul 2 div } var_line
} def
/boltstroke { bolt fill } def
/boltoutline { {bolt} outline } def

/bipoint {
    {i 0 eq i pathcount 1 sub eq or {0} {currentlinewidth 2 div} ifelse}
    var_line
} def

/bipointstroke { bipoint fill } def
/bipointoutline { {bipoint} outline } def

/widthlist { /widths arg
    /width_n widths length def
    {widths i width_n mod get} var_line
} def
/widthliststroke { widthlist fill } def
/widthlistoutline { {widthlist} outline } def


/calligraphic {
    boltdict begin
	/spline_offset exch def
	% /spline_offset 0 def
	% analyze path, moving points into pathpoints array
	pathtocurves

	% determine actual points for drawing
	% place direction and distance to actual point 
	%     into pathpoints entries, fields 4 and 5
        pathcount 1 gt {
            0 1 pathcount 1 sub {
                /i exch def
                % l is last, n is next.  Strange math to make the edges work
                /l i 0 eq { pathcount 2 sub } { i 1 sub } ifelse def
                /n i pathcount 1 sub eq { 1 } { i 1 add } ifelse def

                /cur_point pathpoints i get def
                /x cur_point 0 get def
                /y cur_point 1 get def
                /dist cur_point 2 get def
                /ptype cur_point 3 get def

                /next_point pathpoints n get def
                /nx next_point 0 get def
                /ny next_point 1 get def
                /ndir ny y sub nx x sub atan def

                /last_point pathpoints l get def
                /lx last_point 0 get def
                /ly last_point 1 get def
                /ldir ly y sub lx x sub atan def
                
                /bevel false def
                /direction_2 0 def
                i 0 eq i pathcount 1 sub eq or closed not and {
                    % starting or ending point of stroke - no miter
                    /lineout currentlinewidth 2 div def
                    i 0 eq {
                        /direction ndir 90 add def
                        currentlinecap 2 eq {
                                /x x ndir cos neg lineout mul add def
                                /y y ndir sin neg lineout mul add def
                        } if
                    } {
                        /direction ldir 90 sub def
                        currentlinecap 2 eq {
                                /x x ldir cos neg lineout mul add def
                                /y y ldir sin neg lineout mul add def
                        } if
                    } ifelse
                } {
                    /theta ndir ldir sub def
                    theta 0 lt {
                        /theta theta 360 add def
                    } if
                    /phi 90 theta 2 div sub def
                    % effective line radius at this point
                    /linerad currentlinewidth 2 div def
                    ptype /c eq {
                        /linerad linerad spline_offset mul def
                    } if
                    % actual distance to junction point
                    phi cos 0 eq {
                        /lineout 0 def
                    } {
                        /lineout linerad phi cos div def
                    } ifelse
                    % direction to junction point
                    /direction ndir 90 add phi add def
                    % check miter limit - not for control points
                    0 currentlinejoin ne
                    lineout linerad zdiv currentmiterlimit gt or
                    theta 0 eq or
                    ptype /p eq and {
                        /bevel true def
                        /lineout linerad def
                        /direction ldir 90 sub 360 mymod def
                        /direction_2 ndir 90 add 360 mymod def

                        % special case for end point
                        i pathcount 1 sub eq {
                            /bevel false def
                        } if
                    } if
                } ifelse
                pathpoints i bevel {
                    [x y dist ptype direction lineout bevel direction_2] 
                } {
                    [x y dist ptype direction lineout bevel direction] 
                } ifelse put
            } for
            
            % draw actual path
            newpath

            % starting point
            /cur_point pathpoints 0 get def
            /x cur_point 0 get def
            /y cur_point 1 get def
            /direction cur_point 4 get def
            /lineout cur_point 5 get def
            /bevel cur_point 6 get def
            /direction_2 cur_point 7 get def
            x direction cos lineout mul add
            y direction sin lineout mul add
            moveto
            bevel {
                true drawbevel
            } if

            % lines from 1 to N
            1 1 pathcount 1 sub {
                /i exch def
                /cur_point pathpoints i get def
                /x cur_point 0 get def
                /y cur_point 1 get def
                /ptype cur_point 3 get def
                /direction cur_point 4 get def
                /lineout cur_point 5 get def
                /bevel cur_point 6 get def
                /direction_2 cur_point 7 get def
                x direction cos lineout mul add
                y direction sin lineout mul add
                ptype /p eq {
                    curveto
                } if 
                bevel {
                    true drawbevel
                } if
            } for

            % move to starting point of the line back,
            %     adding circle at end if necessary 
            % even if beveled, direction_1 is appropriate
            currentlinecap 1 eq closed not and {
                x y currentlinewidth 2 div direction direction 180 add arcn
            } {
                /direction direction 180 add def
                x direction cos lineout mul add
                y direction sin lineout mul add
                lineto
            } ifelse

            % lines back
            pathcount 2 sub -1 0 {
                /i exch def
                /cur_point pathpoints i get def
                /x cur_point 0 get def
                /y cur_point 1 get def
                /ptype cur_point 3 get def
                /direction cur_point 4 get 180 add def
                /lineout cur_point 5 get def
                /bevel cur_point 6 get def
                /direction_2 cur_point 7 get 180 add def
                x direction_2 cos lineout mul add
                y direction_2 sin lineout mul add
                ptype /p eq {
                    curveto
                } if 
                bevel {
                    false drawbevel
                }  if
            } for

            % circle at end if necessary
            currentlinecap 1 eq closed not and {
                x y currentlinewidth 2 div direction direction 180 add arcn
            } if
            closepath
        } if
    end
} def

% call with a number argument: thickness of control points
/callistroke { calligraphic fill } def

% call with 2 number arguments: subline width and control point thickness
/callioutline {
    gsave
	calligraphic
	setlinewidth
	stroke
    grestore
    newpath 
} def

/spindly { 0 calligraphic } def
/spindlystroke { 0 callistroke } def
/spindlyoutline { 0 callioutline } def

/brushy { 1 3 div calligraphic } def
/brushystroke { 1 3 div callistroke } def
/brushyoutline { 1 3 div callioutline } def

/softscale {
    dup dup scale
    currentlinewidth exch div setlinewidth
} def

/thicken {
    currentlinewidth mul setlinewidth
} def

/curr_path {
    false
    gsave
	{2 {pop} repeat pop true}
	{2 {pop} repeat pop true}
	{6 {pop} repeat pop true}
	{0 {pop} repeat pop true}
	pathforall
    grestore
} def
/arg { exch def } def
/sparcdict 6 dict def
/sparc {
    sparcdict begin
	/a2 arg
	/a1 arg
	/r arg
	/y arg
	/x arg
	x y translate
	r dup scale
	a1 rotate
	1 0
	curr_path {
	    currentpoint pop 1 sub abs currentlinewidth 10 div lt 
	    currentpoint exch pop 0 sub abs currentlinewidth 10 div lt and
	    {
		pop pop
	    } {
		lineto
	    } ifelse
	} {
	    moveto
	} ifelse
	/adiff a2 a1 sub dup 360 div cvi 360 mul sub def
	adiff 0 lt {
	    /adiff adiff 360 add def
	} if
	/theta adiff 2 div def
	/offset 1 theta cos sub theta sin div 0.75 div def
	1 offset
	adiff cos adiff 90 sub cos offset mul add
	adiff sin adiff 90 sub sin offset mul add
	adiff cos adiff sin
	curveto
	a1 neg rotate
	1 r div dup scale
	x neg y neg translate
    end
} def
/sparcn {
    sparcdict begin
    /a2 arg
    /a1 arg
    /r arg
    /y arg
    /x arg
    -1 1 scale
    x neg y r 180 a1 sub 180 a2 sub sparc
    -1 1 scale
    end
} def

/splitcircle {
    /n arg
    /radius arg
    /y arg
    /x arg
    n {
        x y radius 0 360 n div sparc
    } circrepeat
    closepath
} def

/spcircle {
    3 copy 3 -1 roll add exch moveto
    3 copy 0 180 sparc
    180 0 sparc
    closepath
} def

/ObjectLineDict 15 dict defaultdef
ObjectLineDict begin
    /_rotateobj true defaultdef
    /_ObjectLineto {
        /ny arg /nx arg
        /seglen ny oy sub dup mul nx ox sub dup mul add sqrt def
        ol seglen add separation ge {
            /steps ol seglen add separation div cvi def
            1 1 steps
            {
                /i arg
                /ratio separation i mul ol sub seglen div def
                ratio 0 ne {
                    gsave
                        newpath
                        ox oy translate
                        nx ox sub ratio mul         % position from o
                        ny oy sub ratio mul
                        _rotateobj {
                            2 copy translate
                            exch myatan rotate
                        } {
                            translate
                        } ifelse
                        object
                    grestore
                } if
            } for
            /ol ol steps separation mul sub def
        } if
        /ox nx def /oy ny def /ol ol seglen add def
    } def
end
/ObjectLinePhase {
    ObjectLineDict begin
        /object arg
        /phase arg
        /separation arg
        flattenpath
        { /oy arg /ox arg /ol phase def /cx ox def /cy oy def} %moveto
        {
            _ObjectLineto
        } % lineto
        { die } % curveto
        { cx cy _ObjectLineto } % closepath
        pathforall
    end
} def
/ObjectLine { 0 exch ObjectLinePhase newpath} def

/cstroke { brushystroke } def
/setplain { /cstroke { stroke } def } def
/setbrushy { /cstroke { brushystroke } def } def
/setspindly { /cstroke { spindlystroke } def } def

/returnlines {
    boltdict begin
        false pathtolineslengthp
        pathpoints 0 pathcount getinterval
    end
} def

/intersection {
    /ntheta arg
    /ny arg
    /nx arg
    /otheta arg
    /oy arg
    /ox arg
    % find intersection based on y = mx + b
    otheta cos 0 eq {
        % swap to simplify processing
        otheta ntheta /otheta arg /ntheta arg
    } if
    ntheta cos 0 eq {
        otheta cos 0 eq {
            % both 0, skip out
            /ix ox def /iy oy def
        }
        /om otheta tan def
        /ob oy om ox mul sub def
        /ix nx def
        /iy nx om mul ob add def
    } {
        /om otheta tan def
        /nm ntheta tan def
        om nm eq {
            % if slopes are equal, either parallel or coincident
            /ix ox def
            /iy oy def
        } {
            /ob oy om ox mul sub def
            /nb ny nm nx mul sub def

            /ix nb ob sub om nm sub div def
            /iy ix om mul ob add def
        } ifelse
    } ifelse
    ix iy
} def

/lines_dict 20 dict def
% see lines/splitspline.txt for derivation
lines_dict begin
    /subspline_1d {
        /q arg /p arg
        /D arg /C arg /B arg /A arg

        /xfunc {
            /t arg
            1 A mul
            3 B mul 3 A mul sub                     t mul add
            3 C mul 6 B mul sub 3 A mul add         t mul t mul add
            1 D mul 3 C mul sub 3 B mul add A sub   t mul t mul t mul add
        } def

        /xprime {
            /t arg
            3 B mul  3 A mul sub
            6 C mul 12 B mul sub 6 A mul add                t mul add
            3 D mul  9 C mul sub 9 B mul add 3 A mul sub    t mul t mul add
        } def
        /coeff q p sub 3 div def
        /E p xfunc def
        /H q xfunc def
        /F p xprime coeff mul E add def
        /G q xprime coeff mul H exch sub def
        E F G H
    } def

    /subspline_points {
        /q arg /p arg
        /Dy arg /Dx arg
        /Cy arg /Cx arg
        /By arg /Bx arg
        /Ay arg /Ax arg
        Ax Bx Cx Dx p q subspline_1d /Hx arg /Gx arg /Fx arg /Ex arg
        Ay By Cy Dy p q subspline_1d /Hy arg /Gy arg /Fy arg /Ey arg
        Ex Ey Fx Fy Gx Gy Hx Hy
    } def
end

/splitcurveto {
    lines_dict begin
        /divisions arg
        /Dy arg /Dx arg
        /Cy arg /Cx arg
        /By arg /Bx arg
        currentpoint
        /Ay arg /Ax arg
        0 1 divisions 1 sub {
            /i arg
            Ax Ay Bx By Cx Cy Dx Dy
            i divisions div
            i 1 add divisions div
            subspline_points
            8 -2 roll pop pop
            curveto
        } for
    end
} def

lines_dict begin
    /ca_lean /left def
    /ca_mode /simple def
end
/constrangle_setleft { lines_dict begin /ca_lean /left def end } def
/constrangle_setright { lines_dict begin /ca_lean /right def end } def
/constrangle_setsimple { lines_dict begin /ca_mode /simple def end } def
/constrangle_setclever { lines_dict begin /ca_mode /clever def end } def
/constrangle_path {
    lines_dict begin
        /directions arg
        /angle_increment 360 directions div def
        /pathcount 0 def
        /closed_path false def
        gsave
            { pop pop /pathcount pathcount 1 add def } % moveto
            { pop pop /pathcount pathcount 1 add def } % lineto
            { quit_constrangle_curveto } % curveto
            { /pathcount pathcount 1 add def /closed_path true def} % closepath
            pathforall
        grestore
        /pathpoints pathcount array def
        /pathangles pathcount 1 sub array def
        /i 0 def
        /firstpoint false def
        /addpoint {
            /y arg /x arg
            /point [ x y ] def
            firstpoint false eq {
                /firstpoint point def
            } if
            pathpoints i point put
            i 0 gt {
                pathpoints i 1 sub get aload pop /oy arg /ox arg
                /theta y oy sub x ox sub atan def
                pathangles i 1 sub theta put
            } if
            /i i 1 add def
        } def
        { addpoint } % moveto
        { addpoint } % lineto
        { quit_constrangle_curveto } % curveto
        { firstpoint aload pop addpoint } % closepath
        pathforall
        newpath
        firstpoint aload pop moveto
        0 1 pathcount 2 sub {
            /i arg
            /oldpoint pathpoints i get def
            /newpoint pathpoints i 1 add get def
            oldpoint aload pop /oy arg /ox arg
            newpoint aload pop /ny arg /nx arg
            /line_angle pathangles i get def
            % add intermediate point if necessary
            line_angle angle_increment mymod 0 eq not {
                /angle_coeff line_angle angle_increment div def
                /right_angle angle_coeff floor angle_increment mul def
                /left_angle angle_coeff ceiling angle_increment mul def
                ca_mode /clever eq {
                    /prev_i i 1 sub def
                    /next_i i 1 add def
                    closed_path {
                        /prev_i prev_i pathcount 1 sub mymod def
                        /next_i next_i pathcount 1 sub mymod def
                    } { 
                        prev_i 0 lt { /prev_i i def } if
                        next_i pathcount 2 sub gt { /next_i i def } if
                    } ifelse
                    /prev_angle pathangles prev_i get def
                    /next_angle pathangles next_i get def
                    /prev_bend line_angle prev_angle sub 360 mymod def
                    /next_bend next_angle line_angle sub 360 mymod def
                    /prev_dir
                        prev_bend 0 eq { 0 } {
                            prev_bend 180 gt 
                                { -1 } 
                                { prev_bend 180 lt { 1 } { 0 } ifelse }
                            ifelse
                        } ifelse
                    def
                    /next_dir
                        next_bend 0 eq { 0 } {
                            next_bend 180 gt 
                                { -1 } 
                                { next_bend 180 lt { 1 } { 0 } ifelse }
                            ifelse
                        } ifelse
                    def
                    prev_dir -1 eq {
                        next_dir 1 eq {
                            /lean_dir /lr def
                        } {
                            /lean_dir /right def
                        } ifelse
                    } if
                    prev_dir 0 eq {
                        next_dir 0 eq {
                            /lean_dir ca_lean def
                        } {
                            next_dir -1 eq {
                                /lean_dir /right def
                            } {
                                /lean_dir /left def
                            } ifelse
                        } ifelse
                    } if
                    prev_dir 1 eq {
                        next_dir 1 eq {
                            /lean_dir /rl def
                        } {
                            /lean_dir /left def
                        } ifelse
                    } if
                    lean_dir /left eq {
                        /oangle right_angle def /nangle left_angle def
                    } if
                    lean_dir /right eq {
                        /oangle left_angle def /nangle right_angle def
                    } if
                    lean_dir /lr eq {
                        /mx ox nx add 2 div def
                        /my oy ny add 2 div def
                        /oangle left_angle def
                        /mid_angle right_angle def
                        /nangle left_angle def
                        ox oy oangle mx my mid_angle intersection /iy arg /ix arg
                        ix iy lineto
                        mx my lineto
                        /ox mx def
                        /oy my def
                        /oangle mid_angle def
                    }  if
                    lean_dir /rl eq {
                        /oangle left_angle def /nangle right_angle def
                    } if
                } {
                    ca_lean /left eq {
                        /oangle right_angle def /nangle left_angle def
                    } {
                        /oangle left_angle def /nangle right_angle def
                    } ifelse
                } ifelse
                ox oy oangle nx ny nangle intersection /iy arg /ix arg
                gsave newpath ix iy dot grestore
                ix iy lineto
            } if
            newpoint aload pop lineto
        } for
    end
} def

